\documentclass[natbib,preprint]{sigplanconf}

\usepackage[usenames]{color}
\definecolor{citationcolour}{rgb}{0,0.4,0.2}
\definecolor{linkcolour}{rgb}{0,0,0.8}
\usepackage{hyperref}
\hypersetup{colorlinks=true,
            urlcolor=linkcolour,
            linkcolor=linkcolour,
            citecolor=citationcolour,
            pdftitle=Productive Coprogramming with Guarded Recursion,
            pdfauthor={Robert Atkey, Conor McBride},
            pdfkeywords={}}  
\def\sectionautorefname{Section}
\def\subsectionautorefname{Section}

\title{Productive Coprogramming with Guarded Recursion}

\authorinfo{Robert Atkey}
           { }
           {bob.atkey@gmail.com}

\authorinfo{Conor McBride}
           {University of Strathclyde}
           {Conor.McBride@strath.ac.uk}

\usepackage{mathpartir}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{stmaryrd}

% Colouring in...
\definecolor{highlight}{rgb}{0.8,0.1,0.1}
\definecolor{cons}{rgb}{0.8,0.1,0.2}
\definecolor{elim}{rgb}{0.1,0.5,0.35}
\definecolor{defnd}{rgb}{0.1,0.2,0.8}
\definecolor{greybg}{rgb}{0.8,0.8,0.8}
\newcommand{\highlight}[1]{\textcolor{highlight}{#1}}
\newcommand{\cons}[1]{\textcolor{cons}{\textsf{#1}}}
\newcommand{\elim}[1]{\textcolor{elim}{\textsf{#1}}}
\newcommand{\defnd}[1]{\mathit{#1}}
\newcommand{\kw}[1]{\textbf{#1}}
\newcommand{\tyname}[1]{\textrm{#1}}
\newcommand{\ident}[1]{\textit{#1}}
\newcommand{\defn}[1]{\textcolor{defnd}{\ident{#1}}}

% other stuff
\newcommand{\sepbar}{\mathrel|}
\newcommand{\Set}{\mathsf{Set}}
\newcommand{\sem}[1]{\llbracket #1 \rrbracket}
\newcommand{\op}{\mathsf{op}}
\newcommand{\sortType}{\texttt{\textup{type}}}

\newcommand{\delay}[1]{\mathord{\rhd\kern-0.4em^{#1}}}

\newcommand{\clkSem}[1]{\llbracket #1 \rrbracket}
\newcommand{\ClkPER}{\mathrm{ClkPER}}
\newcommand{\PER}{\mathrm{PER}}
\newcommand{\semCons}[1]{\mathsf{#1}}
\newcommand{\tySem}[1]{\llbracket #1 \rrbracket}

\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\newtheorem{corollary}{Corollary}
\newtheorem{definition}{Definition}

\newcommand{\lemref}[1]{\hyperref[#1]{Lemma \ref*{#1}}}
\newcommand{\thmref}[1]{\hyperref[#1]{Theorem \ref*{#1}}}

\newcommand{\etal}{\textit{et} \textit{al}.}

\newcommand{\fixme}[1]{\textbf{FIXME: #1}}

\begin{document}

\maketitle

\begin{abstract}
  Total functional programming offers the beguiling vision that, just
  by virtue of the compiler accepting a program, we are guaranteed
  that it will always terminate. In the case of programs that are not
  intended to terminate, e.g., servers, we are guaranteed that
  programs will always be \emph{productive}. Productivity means that,
  even if a program generates an infinite amount of data, each piece
  will generated in finite time. The theoretical underpinning for
  productive programming with infinite output is provided by the
  category theoretic notion of final coalgebras. Hence, we speak of
  \emph{co}programming with non-well-founded \emph{co}data, as a dual
  to programming with well-founded data like finite lists and trees.

  Systems that do offer facilities for productive coprogramming, such
  as the proof assistants Coq and Agda, currently do so through
  syntactic guardedness checkers. Syntactic guardedness checkers
  ensure that all self-recursive calls are guarded by a use of a
  constructor. Such a check ensures productivity. Unfortunately, these
  syntactic checks are not compositional, and severely complicate
  coprogramming.

  Guarded recursion, originally due to Nakano, is tantalising as a
  basis for a flexible and compositional type-based approach to
  coprogramming. However, as we show, by itself, guarded recursion is
  not suitable for coprogramming due to the fact that there is no way
  make finite observations on pieces of infinite data. In this paper,
  we introduce the concept of \emph{clock variables} that index
  Nakano's guarded recursion. Clock variables allow us to ``close
  over'' the generation of infinite data, and to make finite
  observations, something that is not possible with guarded recursion
  alone.
\end{abstract}

\category{D.1.1}{Programming techniques}{Applicative (functional)
  programming} \category{D.2.4}{Software Engineering}{Software/Program
  Verification} \category{D.3.3}{Programming Languages}{Language
  Constructs and Features---Data types and structures}

\terms
  Languages, Theory, Types, Recursion

\keywords
  coalgebras, corecursion, guarded recursion, total functional programming

\input{introduction.tex}
\input{type-system.tex}
\input{semantics.tex}
\input{fixpoint-types.tex}
%\input{conclusions.tex}

\paragraph{Acknowledgements} We would like to thank Lars Birkedal and
Rasmus M{\o}gelberg for extremely useful discussions.

\bibliographystyle{plainnat}
\bibliography{paper}

%\appendix
%\input{appendix.tex}


\end{document}
