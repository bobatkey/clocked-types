\section{A Type System}
\label{sec:type-system}

% FIXME: rewrite this introductory paragraph to flow better

In this section we present the type system with guarded recursion and
clock variables that we presented informally in the
\hyperref[sec:introduction]{introduction}. This type system
incorporates a general notion of strictly positive inductive types,
including nested fixpoints, and a guardedness type operator which
allows for the expression of condinductive types. In
\autoref{sec:examples} we present several examples of the use of our
system, including presentations of the informal examples from the
\hyperref[sec:introduction]{introduction}. In \autoref{sec:semantics}
we provide a semantics for this system in terms of an untyped
domain-theoretic model that establishes the soundness properties of
our typing discipline.

% FIXME: justify switch from :: to : for typing

\subsection{Well-formed Types}
\label{sec:types}

\begin{figure}[t]
  \centering
  \begin{mathpar}
    \inferrule*
    {X \in \Theta}
    {\Delta; \Theta \vdash X : \sortType}
    
    \inferrule*
    { }
    {\Delta; \Theta \vdash 1 : \sortType}
    
    \inferrule*
    {\Delta; \Theta \vdash A : \sortType \\ \Delta; \Theta \vdash B : \sortType}
    {\Delta; \Theta \vdash A \times B : \sortType}
    
    \inferrule*
    {\Delta; \Theta \vdash A : \sortType \\ \Delta; \Theta \vdash B : \sortType}
    {\Delta; \Theta \vdash A + B : \sortType}
    
    \inferrule*
    {\Delta; - \vdash A : \sortType \\ \Delta; \Theta \vdash B : \sortType}
    {\Delta; \Theta \vdash A \to B : \sortType}
    
    \inferrule*
    {\Delta; \Theta, X \vdash A : \sortType}
    {\Delta; \Theta \vdash \mu X. A : \sortType}

    \inferrule*
    {\Delta, \kappa; \Theta \vdash A : \sortType}
    {\Delta; \Theta \vdash \forall \kappa. A : \sortType}

    \inferrule*
    {\Delta; \Theta \vdash A : \sortType \\ \kappa \in \Delta}
    {\Delta; \Theta \vdash \delay\kappa A : \sortType}
  \end{mathpar}
  \caption{Well-formed types and type operators}
  \label{fig:types}
\end{figure}

The well-formed types are generated by the rules in
\autoref{fig:types}. FIXME

\subsection{Type Equality}\label{sec:type-equality}

The following rules establish an equivalence relation on well-formed
types. These are intended to be read as a judgement $\Delta \vdash A
\equiv B$.
\begin{eqnarray*}
  \forall \kappa. A & \equiv & A\hspace{2.3cm}(\kappa \not\in \mathit{fv}(A)) \\
  \forall \kappa. A + B & \equiv & (\forall \kappa. A) + (\forall \kappa. B) \\
  \forall \kappa. A \times B & \equiv & (\forall \kappa. A) \times (\forall \kappa. B) \\
  \forall \kappa. A \to B & \equiv & A \to \forall \kappa. B\hspace{1cm}(\kappa \not\in \mathit{fv}(A)) \\
  \forall \kappa. \forall \kappa'. A & \equiv & \forall \kappa'. \forall \kappa. A \\
  \forall \kappa. \delay\kappa' A & \equiv & \delay\kappa'\forall \kappa. A\hspace{1.35cm}(\kappa \not= \kappa') \\
  \forall \kappa. \mu X. F & \equiv & \mu X. \forall \kappa. F\hspace{1.15cm}(\kappa \not\in \mathit{fv}(F))
\end{eqnarray*}
We also assume the obvious rules for congruence, reflexivity, symmetry
and transitivity.

These rules express the fact that clock quantification is
``computationally irrelevant''. FIXME

Many of them can be expressed by means of re-arranging quantifiers,
but it is more convienent here to have them as type equalities.

\subsection{Well-typed Terms}\label{sec:typed-terms}

\begin{figure*}[t]
  \centering
  \textbf{Simply-typed $\lambda$-calculus with products and sums}
  \begin{mathpar}
    \inferrule* [right=Var]
    {\ident{x} : A \in \Gamma}
    {\Delta; \Gamma \vdash \ident{x} : A}

    \inferrule* [right=Unit]
    { }
    {\Delta; \Gamma \vdash * : 1}

    \inferrule* [right=Abs]
    {\Delta; \Gamma, \ident{x} : A \vdash e : B}
    {\Delta; \Gamma \vdash \lambda \ident{x}.\ e : A \to B}

    \inferrule* [right=App]
    {\Delta; \Gamma \vdash f : A \to B \\
      \Delta; \Gamma \vdash e : A}
    {\Delta; \Gamma \vdash f e : B}

    \inferrule* [right=Pair]
    {\Delta; \Gamma \vdash e_1 : A \\
      \Delta; \Gamma \vdash e_2 : B}
    {\Delta; \Gamma \vdash (e_1, e_2) : A \times B}

    \inferrule* [right=Fst]
    {\Delta; \Gamma \vdash e : A \times B}
    {\Delta; \Gamma \vdash \kw{fst}\ e : A}

    \inferrule* [right=Snd]
    {\Delta; \Gamma \vdash e : A \times B}
    {\Delta; \Gamma \vdash \kw{snd}\ e : B}

    \inferrule* [right=Inl]
    {\Delta; \Gamma \vdash e : A}
    {\Delta; \Gamma \vdash \kw{inl}\ e : A + B}

    \inferrule* [right=Inr]
    {\Delta; \Gamma \vdash e : B}
    {\Delta; \Gamma \vdash \kw{inr}\ e : A + B}

    \inferrule* [right=Case]
    {\Delta; \Gamma \vdash e : A + B \\
      \Delta; \Gamma, \ident{x} : A \vdash f : C \\
      \Delta; \Gamma, \ident{y} : B \vdash g : C}
    {\Delta; \Gamma \vdash
      \kw{case}\ e\ \kw{of}\ \kw{inl}\ \ident{x}. f;
      \kw{inr}\ \ident{y}. g : C}
  \end{mathpar}

  \bigskip

  \textbf{Clock Abstraction and Application, and Type Equality}
  \begin{mathpar}
    \inferrule* [right=$\kappa$-Abs]
    {\Delta, \kappa; \Gamma \vdash e : A \\ \kappa \not\in \mathit{fv}(\Gamma)}
    {\Delta; \Gamma \vdash \Lambda \kappa. e : \forall \kappa. A}

    \inferrule* [right=$\kappa$-App]
    {\Delta; \Gamma \vdash e : \forall \kappa. A \\ \kappa' \in \Delta \\ \kappa' \not\in \mathit{fv}(A)}
    {\Delta; \Gamma \vdash e[\kappa'] : A[\kappa \mapsto \kappa']}
      
    \inferrule* [right=TyEq]
    {\Delta; \Gamma \vdash e : A \\ \Delta \vdash A \equiv B}
    {\Delta; \Gamma \vdash e : B}
  \end{mathpar}

  \bigskip

  \textbf{Applicative Functor Structure for $\delay\kappa-$}
  \begin{mathpar}
    \inferrule* [right=DePure]
    {\Delta; \Gamma \vdash e : A \\ \kappa \in \Delta}
    {\Delta; \Gamma \vdash \kw{pure}\ e : \delay\kappa A}
    
    \inferrule* [right=DeApp]
    {\Delta; \Gamma \vdash f : \delay\kappa (A \to B) \\
      \Delta; \Gamma \vdash e : \delay\kappa A}
    {\Delta; \Gamma \vdash f \circledast e : \delay\kappa B}
  \end{mathpar}

  \bigskip
  \textbf{Fix and Force}
  \begin{mathpar}
    \inferrule* [right=Fix]
    {\Delta; \Gamma \vdash f : \delay\kappa A \to A}
    {\Delta; \Gamma \vdash \kw{fix}\ f : A}

    \inferrule* [right=Force]
    {\Delta; \Gamma \vdash e : \forall \kappa. \delay\kappa A}
    {\Delta; \Gamma \vdash \kw{force}\ e : \forall \kappa. A}
  \end{mathpar}

  \bigskip
  
  \textbf{Least Fixpoint Types}
  \begin{mathpar}
    \inferrule* [right=Cons]
    {\Delta; \Gamma \vdash e : F[\mu X. F]}
    {\Delta; \Gamma \vdash \cons{Cons$_F$}\ e : \mu X. F}

    \inferrule* [right=PrimRec]
    {\Delta; \Gamma \vdash e : F[(\mu X. F) \times A] \to A}
    {\Delta; \Gamma \vdash \elim{primRec$_F$}\ e : \mu X. F \to A}
  \end{mathpar}
  \caption{Well-typed terms}
  \label{fig:terms}
\end{figure*}

The rules generating the well-typed terms are shown in
\autoref{fig:terms}.
FIXME:
\begin{enumerate}
\item Define contexts
\item Define the judgement of well-typedness
\item Walk through some of the typing rules
\item Define $\ident{fmap}_F$ for all $F$.
\end{enumerate}

\subsection{Examples}\label{sec:examples}

\paragraph{(Co)inductive Types}

\paragraph{Stream Eating}

Example type: $\forall \kappa. \mu X. \mu Y. A + (I \to Y) + (O \times
\delay\kappa X)$. Stream eating functions that consume finite amounts
of input for every output. Should be able to define the application
and composition operations.

\paragraph{Non-termination Monad}

$T A = \forall \kappa. \mu X. A + \delay\kappa X$

Escardo?

\paragraph{Circular Programming} Refer back to the replaceMin example.

%%% Local Variables:
%%% TeX-master: "paper"
%%% End:
